{% extends "base.html" %}
{% block content %}
  <section class="card detail-card scorecard-panel">
    <div class="scorecard-header scorecard-header--simple">
      <div class="scorecard-summary">
        <div class="scorecard-topline">
          <span class="match-chip" id="scorecard-division-chip">Division {{ scorecard.division }}</span>
          <span class="match-chip" id="scorecard-match-chip">Match {{ scorecard.match_key }}</span>
        </div>
        <p class="match-handicaps">
          <span id="scorecard-header-player-a">{{ scorecard.player_a }}</span>
          (hcp <span id="scorecard-header-a-handicap">{{ scorecard.player_a_handicap }}</span>)
          vs
          <span id="scorecard-header-player-b">{{ scorecard.player_b }}</span>
          (hcp <span id="scorecard-header-b-handicap">{{ scorecard.player_b_handicap }}</span>)
        </p>
        {% if status %}
          <div class="status score-status">{{ status }}</div>
        {% endif %}
      </div>
    </div>

    <section
      class="hole-entry-section"
      data-player-a-handicap="{{ scorecard.player_a_handicap }}"
      data-player-b-handicap="{{ scorecard.player_b_handicap }}"
    >
      <div class="setup-head">
        <h2>Hole-by-hole entry</h2>
        <p class="match-sub">Record gross scores for each hole and let the net math happen automatically.</p>
        <div class="hole-player-tags">
          <span class="hole-player-pill" id="hole-player-a-label">{{ scorecard.player_a }}</span>
          <span class="hole-player-pill" id="hole-player-b-label">{{ scorecard.player_b }}</span>
        </div>
      </div>
      <div class="mobile-hole-shell">
        <div class="mobile-hole-header" id="mobile-hole-header">
          <button type="button" class="mobile-hole-nav-btn" id="mobile-hole-prev">◀</button>
          <div class="mobile-hole-meta">
            <div class="mobile-hole-title">Hole <span id="mobile-hole-number">1</span></div>
            <div class="mobile-hole-sub" id="mobile-hole-sub">Par —</div>
          </div>
          <button type="button" class="mobile-hole-nav-btn" id="mobile-hole-next">▶</button>
        </div>
        <div class="mobile-hole-nav" id="mobile-hole-nav"></div>
        <form id="hole-form" class="hole-entry-form">
          <div id="hole-rows" class="hole-inputs"></div>
          <div class="setup-actions">
            <button type="button" id="add-hole-btn" class="add-player-btn">Add hole</button>
          </div>
        </form>
      </div>
      <div id="mobile-scoring" class="mobile-scoring">
        <div class="mobile-hole-bar">
          <button type="button" class="mobile-hole-nav-btn" id="mobile-hole-prev2">‹ Hole</button>
          <div class="mobile-hole-info">
            <div class="mobile-hole-title">Hole <span id="mobile-hole-number-2">1</span></div>
            <div class="mobile-hole-sub" id="mobile-hole-sub-2">Par —</div>
          </div>
          <button type="button" class="mobile-hole-nav-btn" id="mobile-hole-next2">Hole ›</button>
        </div>
        <div class="mobile-player-list">
          <div class="mobile-player" data-role="a">
            <div class="mobile-player-row">
              <div class="mobile-player-name" id="mobile-player-a-name">Player A</div>
              <div class="mobile-player-hcp" id="mobile-player-a-hcp"></div>
              <div class="mobile-player-stroke" id="mobile-player-a-stroke"></div>
            </div>
            <input type="text" inputmode="numeric" pattern="[0-9]*" id="mobile-input-a" />
          </div>
          <div class="mobile-player" data-role="b">
            <div class="mobile-player-row">
              <div class="mobile-player-name" id="mobile-player-b-name">Player B</div>
              <div class="mobile-player-hcp" id="mobile-player-b-hcp"></div>
              <div class="mobile-player-stroke" id="mobile-player-b-stroke"></div>
            </div>
            <input type="text" inputmode="numeric" pattern="[0-9]*" id="mobile-input-b" />
          </div>
        </div>
      </div>
      <div class="mobile-keypad" id="mobile-keypad">
        <div class="mobile-keypad-row">
          <button type="button" data-key="1">1</button>
          <button type="button" data-key="2">2</button>
          <button type="button" data-key="3">3</button>
        </div>
        <div class="mobile-keypad-row">
          <button type="button" data-key="4">4</button>
          <button type="button" data-key="5">5</button>
          <button type="button" data-key="6">6</button>
        </div>
        <div class="mobile-keypad-row">
          <button type="button" data-key="7">7</button>
          <button type="button" data-key="8">8</button>
          <button type="button" data-key="9">9</button>
        </div>
        <div class="mobile-keypad-row">
          <button type="button" data-key="clear" class="ghost">Clear</button>
          <button type="button" data-key="0">0</button>
          <button type="button" data-key="back" class="ghost">⌫</button>
        </div>
        <div class="mobile-keypad-row actions">
          <button type="button" id="mobile-undo" class="ghost">Undo Changes</button>
          <button type="button" id="mobile-save" class="solid">Save Scores</button>
        </div>
      </div>
    </section>
  </section>

  <template id="hole-input-template">
      <div class="hole-entry-row">
        <div class="hole-field">
          <label>Hole</label>
          <input type="number" name="hole_number" min="1" placeholder="1" required />
          <label class="hole-hcp-label">HCP</label>
          <input type="text" class="hole-handicap" name="hole_handicap" inputmode="numeric" pattern="[0-9]*" placeholder="—" readonly />
        </div>
        <div class="hole-field">
          <label><span data-hole-label-a>Player A gross</span></label>
          <input type="text" name="player_a_score" inputmode="numeric" pattern="[0-9]*" required />
          <small>Net <span data-net-role="a">0</span></small>
          <span class="stroke-star" data-stroke-star="a"></span>
        </div>
        <div class="hole-field">
          <label><span data-hole-label-b>Player B gross</span></label>
          <input type="text" name="player_b_score" inputmode="numeric" pattern="[0-9]*" required />
          <small>Net <span data-net-role="b">0</span></small>
          <span class="stroke-star" data-stroke-star="b"></span>
        </div>
      <div class="hole-points-box">
        <label>Points</label>
        <div class="hole-points-stack" data-points-role>—</div>
      </div>
    </div>
  </template>

  <script>
    let courseHoles = {{ course_holes | tojson }};
    const divisionChip = document.getElementById("scorecard-division-chip");
    const matchChip = document.getElementById("scorecard-match-chip");
    const headerPlayerAName = document.getElementById("scorecard-header-player-a");
    const headerPlayerBName = document.getElementById("scorecard-header-player-b");
    const headerAHandicap = document.getElementById("scorecard-header-a-handicap");
    const headerBHandicap = document.getElementById("scorecard-header-b-handicap");
    const holePlayerALabel = document.getElementById("hole-player-a-label");
    const holePlayerBLabel = document.getElementById("hole-player-b-label");
    const strokeSummary = document.getElementById("stroke-summary");
    const divisionTitle = document.getElementById("scorecard-division");
    const keyTitle = document.getElementById("scorecard-match-key");
    const entrySection = document.querySelector(".hole-entry-section");
    const holeContainer = document.getElementById("hole-rows");
    const mobileNav = document.getElementById("mobile-hole-nav");
    const mobileHeader = document.getElementById("mobile-hole-header");
    const mobileHoleNumber = document.getElementById("mobile-hole-number");
    const mobileHoleSub = document.getElementById("mobile-hole-sub");
    const mobilePrev = document.getElementById("mobile-hole-prev");
    const mobileNext = document.getElementById("mobile-hole-next");
    const mobileKeypad = document.getElementById("mobile-keypad");
    const mobileSave = document.getElementById("mobile-save");
    const mobileUndo = document.getElementById("mobile-undo");
    const mobileContainer = document.getElementById("mobile-scoring");
    const mobileHoleNumber2 = document.getElementById("mobile-hole-number-2");
    const mobileHoleSub2 = document.getElementById("mobile-hole-sub-2");
    const mobilePrev2 = document.getElementById("mobile-hole-prev2");
    const mobileNext2 = document.getElementById("mobile-hole-next2");
    const mobilePlayerAName = document.getElementById("mobile-player-a-name");
    const mobilePlayerBName = document.getElementById("mobile-player-b-name");
    const mobilePlayerAHcp = document.getElementById("mobile-player-a-hcp");
    const mobilePlayerBHcp = document.getElementById("mobile-player-b-hcp");
    const mobilePlayerAStroke = document.getElementById("mobile-player-a-stroke");
    const mobilePlayerBStroke = document.getElementById("mobile-player-b-stroke");
    const mobileInputA = document.getElementById("mobile-input-a");
    const mobileInputB = document.getElementById("mobile-input-b");
    const template = document.getElementById("hole-input-template");
    const standardHoleCount = 18;
    let mobileActiveHole = 1;
    let activeInput = null;
    let lastValues = new Map();

    const updateStrokeSummary = (handicapA, handicapB) => {
      if (!strokeSummary) return;
      const diff = handicapA - handicapB;
      if (diff === 0) {
        strokeSummary.textContent = "Strokes: none allocated";
        return;
      }
      const receiver = diff > 0 ? (holePlayerBLabel?.textContent || "Player B") : (holePlayerALabel?.textContent || "Player A");
      const strokes = Math.abs(diff);
      strokeSummary.textContent = `${receiver} gets ${strokes} stroke${strokes === 1 ? "" : "s"} total`;
    };

    const updateScorecard = (summary) => {
      if (divisionChip) {
        divisionChip.textContent = `Division ${summary.division || "A"}`;
      }
      if (matchChip) {
        matchChip.textContent = `Match ${summary.match_key || ""}`;
      }
      if (headerPlayerAName) {
        headerPlayerAName.textContent = summary.player_a;
      }
      if (headerPlayerBName) {
        headerPlayerBName.textContent = summary.player_b;
      }
      if (headerAHandicap) {
        headerAHandicap.textContent = summary.player_a_handicap;
      }
      if (headerBHandicap) {
        headerBHandicap.textContent = summary.player_b_handicap;
      }
      if (divisionTitle) {
        divisionTitle.textContent = summary.division || "Open";
      }
      if (keyTitle) {
        keyTitle.textContent = summary.match_key || "";
      }
      if (holePlayerALabel) {
        holePlayerALabel.textContent = summary.player_a;
      }
      if (holePlayerBLabel) {
        holePlayerBLabel.textContent = summary.player_b;
      }
      if (mobilePlayerAName) {
        mobilePlayerAName.textContent = summary.player_a;
      }
      if (mobilePlayerBName) {
        mobilePlayerBName.textContent = summary.player_b;
      }
      if (mobilePlayerAHcp) {
        mobilePlayerAHcp.textContent = `(${summary.player_a_handicap})`;
      }
      if (mobilePlayerBHcp) {
        mobilePlayerBHcp.textContent = `(${summary.player_b_handicap})`;
      }
      if (summary.course_holes) {
        courseHoles = summary.course_holes;
      }
      updateStrokeSummary(Number(summary.player_a_handicap), Number(summary.player_b_handicap));
      if (entrySection) {
        entrySection.dataset.playerAHandicap = summary.player_a_handicap;
        entrySection.dataset.playerBHandicap = summary.player_b_handicap;
        entrySection.dataset.matchKey = summary.match_key;
        renderHoleEntryRows(summary.holes);
      }
    };

    const holeHandicapLookup = (holeNumber) => {
      if (!courseHoles || !Array.isArray(courseHoles)) return null;
      const found = courseHoles.find((h) => Number(h.hole_number) === Number(holeNumber));
      return found ? Number(found.handicap) : null;
    };

    const strokeAllocationForHole = (handicap, holeHandicap) => {
      if (!holeHandicap) return 0;
      const base = Math.floor(handicap / 18);
      const remainder = handicap % 18;
      const extra = remainder && holeHandicap <= remainder ? 1 : 0;
      return base + extra;
    };

    const updateRow = (row) => {
      const holeInput = row.querySelector('input[name="hole_number"]');
      const aInput = row.querySelector('input[name="player_a_score"]');
      const bInput = row.querySelector('input[name="player_b_score"]');
      const hcpInput = row.querySelector('input[name="hole_handicap"]');
      const labelA = row.querySelector("[data-hole-label-a]");
      const labelB = row.querySelector("[data-hole-label-b]");
      if (labelA) {
        labelA.textContent = holePlayerALabel?.textContent
          ? `${holePlayerALabel.textContent} gross`
          : "Player A gross";
      }
      if (labelB) {
        labelB.textContent = holePlayerBLabel?.textContent
          ? `${holePlayerBLabel.textContent} gross`
          : "Player B gross";
      }
      const holeNumber = Number(holeInput.value) || Number(row.dataset.defaultHole) || 1;
      row.dataset.holeNumber = holeNumber;
      const courseHcp = holeHandicapLookup(holeNumber);
      if (hcpInput && courseHcp) {
        hcpInput.value = courseHcp;
      }
      const holeHandicap = Number(hcpInput?.value) || null;
      const strokesA = strokeAllocationForHole(Number(entrySection.dataset.playerAHandicap), holeHandicap);
      const strokesB = strokeAllocationForHole(Number(entrySection.dataset.playerBHandicap), holeHandicap);
      const netA =
        aInput.value !== ""
          ? Number(aInput.value) - strokesA
          : null;
      const netB =
        bInput.value !== ""
          ? Number(bInput.value) - strokesB
          : null;
      const netSpanA = row.querySelector('[data-net-role="a"]');
      const netSpanB = row.querySelector('[data-net-role="b"]');
      const strokeStarA = row.querySelector('[data-stroke-star="a"]');
      const strokeStarB = row.querySelector('[data-stroke-star="b"]');
      const pointsStack = row.querySelector('[data-points-role]');
      if (netSpanA) {
        netSpanA.textContent = netA !== null ? netA : "—";
      }
      if (netSpanB) {
        netSpanB.textContent = netB !== null ? netB : "—";
      }
      if (strokeStarA) {
        strokeStarA.textContent = strokesA > 0 ? "*".repeat(strokesA) : "";
      }
      if (strokeStarB) {
        strokeStarB.textContent = strokesB > 0 ? "*".repeat(strokesB) : "";
      }
      if (mobilePlayerAStroke && number === mobileActiveHole) {
        mobilePlayerAStroke.textContent = strokesA > 0 ? "*".repeat(strokesA) : "";
      }
      if (mobilePlayerBStroke && number === mobileActiveHole) {
        mobilePlayerBStroke.textContent = strokesB > 0 ? "*".repeat(strokesB) : "";
      }
      if (pointsStack) {
        if (netA !== null && netB !== null) {
          const nameA = (holePlayerALabel?.textContent || "Player A").split(" ").slice(-1).join(" ") || holePlayerALabel?.textContent || "Player A";
          const nameB = (holePlayerBLabel?.textContent || "Player B").split(" ").slice(-1).join(" ") || holePlayerBLabel?.textContent || "Player B";
          if (netA < netB) {
            pointsStack.innerHTML = `<div>${nameA}: 1</div><div>${nameB}: 0</div>`;
          } else if (netA > netB) {
            pointsStack.innerHTML = `<div>${nameA}: 0</div><div>${nameB}: 1</div>`;
          } else {
            pointsStack.innerHTML = `<div>${nameA}: 0.5</div><div>${nameB}: 0.5</div>`;
          }
        } else {
          pointsStack.textContent = "—";
        }
      }
    };

    const bindRow = (row) => {
      row.querySelectorAll("input").forEach((input) => {
        input.addEventListener("input", () => {
          updateRow(row);
        });
        input.addEventListener("focus", () => {
          activeInput = input;
        });
      });
      updateRow(row);
    };

    const addHoleRow = (holeNumber = "", data = null) => {
      if (!template || !holeContainer) {
        return;
      }
      const clone = template.content.cloneNode(true);
      const row = clone.querySelector(".hole-entry-row");
      const holeInput = row.querySelector('input[name="hole_number"]');
      const aInput = row.querySelector('input[name="player_a_score"]');
      const bInput = row.querySelector('input[name="player_b_score"]');
      const hcpInput = row.querySelector('input[name="hole_handicap"]');
      if (data) {
        holeInput.value = data.hole_number || holeNumber;
        aInput.value = data.player_a_score;
        bInput.value = data.player_b_score;
        row.dataset.defaultHole = data.hole_number;
        if (hcpInput) {
          if (data.hole_handicap) {
            hcpInput.value = data.hole_handicap;
          } else {
            const courseHcp = holeHandicapLookup(holeInput.value || holeNumber);
            if (courseHcp) hcpInput.value = courseHcp;
          }
        }
      } else {
        holeInput.value = holeNumber || "";
        row.dataset.defaultHole = holeInput.value || holeNumber || "";
        if (hcpInput) {
          const courseHcp = holeHandicapLookup(holeNumber);
          if (courseHcp) hcpInput.value = courseHcp;
        }
      }
      row.dataset.holeNumber = holeInput.value || holeNumber || "";
      holeContainer.appendChild(row);
      bindRow(row);
    };

    const renderHoleEntryRows = (holes = []) => {
      if (!holeContainer) {
        return;
      }
      const holeData = {};
      holes.forEach((hole) => {
        const number = Number(hole.hole_number) || 0;
        if (number > 0) {
          holeData[number] = hole;
        }
      });
      holeContainer.innerHTML = "";
      for (let holeNumber = 1; holeNumber <= standardHoleCount; holeNumber += 1) {
        addHoleRow(holeNumber, holeData[holeNumber]);
      }
      holes
        .filter((hole) => Number(hole.hole_number) > standardHoleCount)
        .forEach((hole) => addHoleRow(Number(hole.hole_number), hole));
      refreshMobileNav();
    };

    updateScorecard({{ scorecard | tojson }});

    const addHoleButton = document.getElementById("add-hole-btn");
    const saveHolesButton = document.getElementById("save-holes-btn");

    if (addHoleButton) {
      addHoleButton.addEventListener("click", () => addHoleRow());
    }

    const refreshMobileNav = () => {
      if (!mobileNav || !holeContainer) return;
      mobileNav.innerHTML = "";
      const rows = Array.from(holeContainer.querySelectorAll(".hole-entry-row"));
      const seen = new Set();
      rows.forEach((row) => {
        const num = Number(row.dataset.holeNumber) || Number(row.dataset.defaultHole) || 1;
        if (seen.has(num)) return;
        seen.add(num);
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = num;
        btn.className = "mobile-hole-btn" + (num === mobileActiveHole ? " active" : "");
        btn.addEventListener("click", () => {
          mobileActiveHole = num;
          applyMobileActive();
          refreshMobileNav();
        });
        mobileNav.appendChild(btn);
      });
      applyMobileActive();
    };

    const applyMobileActive = () => {
      if (!holeContainer) return;
      const rows = Array.from(holeContainer.querySelectorAll(".hole-entry-row"));
      const isMobile = window.matchMedia("(max-width: 900px)").matches;
      rows.forEach((row) => {
        const num = Number(row.dataset.holeNumber) || Number(row.dataset.defaultHole) || 1;
        if (isMobile) {
          row.classList.toggle("mobile-hidden", num !== mobileActiveHole);
        } else {
          row.classList.remove("mobile-hidden");
        }
      });
      if (mobileHoleNumber) {
        mobileHoleNumber.textContent = mobileActiveHole;
      }
      if (mobileHoleNumber2) {
        mobileHoleNumber2.textContent = mobileActiveHole;
      }
      if (mobileHoleSub && courseHoles) {
        const holeMeta = courseHoles.find((h) => Number(h.hole_number) === Number(mobileActiveHole));
        const par = holeMeta?.par ? `Par ${holeMeta.par}` : "";
        const yards = holeMeta?.yardage ? `${holeMeta.yardage} yds` : "";
        const bits = [par, yards].filter(Boolean).join(" • ");
        mobileHoleSub.textContent = bits || "";
      }
      if (mobileHoleSub2 && courseHoles) {
        const holeMeta = courseHoles.find((h) => Number(h.hole_number) === Number(mobileActiveHole));
        const par = holeMeta?.par ? `Par ${holeMeta.par}` : "";
        const yards = holeMeta?.yardage ? `${holeMeta.yardage} yds` : "";
        const bits = [par, yards].filter(Boolean).join(" • ");
        mobileHoleSub2.textContent = bits || "";
      }
      if (isMobile) {
        setTimeout(() => {
          const activeRow = rows.find((row) => !(row.classList.contains("mobile-hidden")));
          if (activeRow) {
            const grossA = activeRow.querySelector('input[name="player_a_score"]');
            const grossB = activeRow.querySelector('input[name="player_b_score"]');
            activeInput = grossB || grossA || activeInput;
            if (mobileInputA && grossA && num === mobileActiveHole) {
              mobileInputA.value = grossA.value || "";
            }
            if (mobileInputB && grossB && num === mobileActiveHole) {
              mobileInputB.value = grossB.value || "";
            }
          }
        }, 0);
      }
    };

    if (saveHolesButton) {
      saveHolesButton.addEventListener("click", async () => {
        if (!holeContainer || !entrySection) {
          return;
        }
        const rows = Array.from(holeContainer.querySelectorAll(".hole-entry-row"))
          .map((row) => {
            const holeInput = row.querySelector('input[name="hole_number"]');
            const aInput = row.querySelector('input[name="player_a_score"]');
            const bInput = row.querySelector('input[name="player_b_score"]');
            if (!holeInput || !aInput || !bInput) {
              return null;
            }
            if (!row.dataset.defaultHole && !holeInput.value) {
              return null;
            }
            return {
              hole_number: holeInput.value || row.dataset.defaultHole,
              player_a_score: aInput.value,
              player_b_score: bInput.value,
              hole_handicap: row.querySelector('input[name="hole_handicap"]')?.value || "",
            };
          })
          .filter(
            (entry) => entry && entry.player_a_score !== "" && entry.player_b_score !== ""
          );
        if (!rows.length) {
          return;
        }
        const response = await fetch(`/matches/${entrySection.dataset.matchKey}/holes`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ holes: rows }),
        });
        if (response.ok) {
          const summaryResponse = await fetch(`/api/match-summary/${entrySection.dataset.matchKey}`);
          if (summaryResponse.ok) {
            const data = await summaryResponse.json();
            updateScorecard(data);
          }
        }
      });
    }

    window.addEventListener("resize", applyMobileActive);

    if (mobilePrev) {
      mobilePrev.addEventListener("click", () => {
        mobileActiveHole = Math.max(1, mobileActiveHole - 1);
        applyMobileActive();
        refreshMobileNav();
      });
    }
    if (mobileNext) {
      mobileNext.addEventListener("click", () => {
        const maxHole = Math.max(
          ...Array.from(holeContainer?.querySelectorAll(".hole-entry-row") || []).map((r) => Number(r.dataset.holeNumber) || 1)
        );
        mobileActiveHole = Math.min(maxHole, mobileActiveHole + 1);
        applyMobileActive();
        refreshMobileNav();
      });
    }
    if (mobilePrev2) {
      mobilePrev2.addEventListener("click", () => {
        mobileActiveHole = Math.max(1, mobileActiveHole - 1);
        applyMobileActive();
        refreshMobileNav();
      });
    }
    if (mobileNext2) {
      mobileNext2.addEventListener("click", () => {
        const maxHole = Math.max(
          ...Array.from(holeContainer?.querySelectorAll(".hole-entry-row") || []).map((r) => Number(r.dataset.holeNumber) || 1)
        );
        mobileActiveHole = Math.min(maxHole, mobileActiveHole + 1);
        applyMobileActive();
        refreshMobileNav();
      });
    }

    const keypadHandler = (key) => {
      if (!activeInput) {
        // try selecting mobile inputs on the active hole
        const rows = Array.from(holeContainer?.querySelectorAll(".hole-entry-row") || []);
        const activeRow = rows.find((row) => Number(row.dataset.holeNumber) === mobileActiveHole && !row.classList.contains("mobile-hidden"));
        if (activeRow) {
          activeInput =
            (key && key !== "clear" && key !== "back" ? activeRow.querySelector('input[name="player_b_score"]') : null) ||
            activeRow.querySelector('input[name="player_a_score"]');
        }
      }
      if (!activeInput) return;
      const current = activeInput.value || "";
      if (!lastValues.has(activeInput)) {
        lastValues.set(activeInput, current);
      }
      if (key === "clear") {
        activeInput.value = "";
      } else if (key === "back") {
        activeInput.value = current.slice(0, -1);
      } else {
        activeInput.value = current + key;
      }
      activeInput.dispatchEvent(new Event("input"));
      if (activeInput === (document.activeElement)) {
        activeInput.blur();
      }
      if (activeInput === (mobileInputA) && mobileInputA) {
        mobileInputA.value = activeInput.value;
      }
      if (activeInput === (mobileInputB) && mobileInputB) {
        mobileInputB.value = activeInput.value;
      }
    };

    if (mobileKeypad) {
      mobileKeypad.querySelectorAll("button[data-key]").forEach((btn) => {
        btn.addEventListener("click", () => keypadHandler(btn.dataset.key));
      });
    }

    if (mobileSave) {
      mobileSave.addEventListener("click", () => saveHolesButton?.click());
    }

    if (mobileUndo) {
      mobileUndo.addEventListener("click", () => {
        lastValues.forEach((val, input) => {
          input.value = val;
          input.dispatchEvent(new Event("input"));
        });
        lastValues.clear();
      });
    }
  </script>

{% endblock %}
